\documentclass[a4paper,twocolumn]{article}


\usepackage[sc]{mathpazo} % Use the Palatino font
\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
\usepackage[utf8]{inputenc} % Use utf-8 as encoding
\linespread{1.05} % Line spacing - Palatino needs more space between lines
\usepackage{microtype} % Slightly tweak font spacing for aesthetics
\usepackage{graphicx}

\usepackage[spanish]{babel} % Language hyphenation and typographical rules
%\usepackage[galician]{babel} % Change to this if using galician

\usepackage[hmarginratio=1:1,top=32mm,columnsep=20pt]{geometry} % Document margins
\usepackage[hang, small,labelfont=bf,up,textfont=it,up]{caption} % Custom captions under/above floats in tables or figures
\usepackage{booktabs} % Horizontal rules in tables

\usepackage{enumitem} % Customized lists
\setlist[itemize]{noitemsep} % Make itemize lists more compact

\usepackage{abstract} % Allows abstract customization
\renewcommand{\abstractnamefont}{\normalfont\bfseries} % Set the "Abstract" text to bold
\renewcommand{\abstracttextfont}{\normalfont\small\itshape} % Set the abstract itself to small italic text

\usepackage{titlesec} % Allows customization of titles
\renewcommand\thesection{\Roman{section}} % Roman numerals for the sections
\renewcommand\thesubsection{\Alph{subsection}} % roman numerals for subsections
\titleformat{\section}[block]{\large\scshape\centering}{\thesection.}{1em}{} % Change the look of the section titles
\titleformat{\subsection}[block]{\large}{\thesubsection.}{1em}{} % Change the look of the section titles

\usepackage{fancyhdr} % Headers and footers
\pagestyle{fancy} % All pages have headers and footers
\fancyhead{} % Blank out the default header
\fancyfoot{} % Blank out the default footer
%\fancyhead[C]{Running title $\bullet$ May 2016 $\bullet$ Vol. XXI, No. 1} % Custom header text
\fancyfoot[C]{\thepage} % Custom footer text

\usepackage{titling} % Customizing the title section

\usepackage{hyperref} % For hyperlinks in the PDF

\usepackage{listings}
\usepackage{xcolor}

\usepackage{float}

\usepackage{amsmath}

% Configuración de los listings para mostrar código
\lstset{
    language=C,                % Lenguaje de programación
    basicstyle=\small\ttfamily, % Estilo básico y tamaño de fuente
    keywordstyle=\color{blue}, % Estilo de las palabras clave
    stringstyle=\color{red},   % Estilo de las cadenas de texto
    commentstyle=\color{purple},% Estilo de los comentarios
    morecomment=[l][\color{magenta}]{\#},  % Estilo de los preprocesadores
    breaklines=true,           % Permite que las líneas se partan
    breakatwhitespace=true,    % Los cortes de línea ocurren en los espacios en blanco
    tabsize=4,                 % Tamaño de tabulación
    showstringspaces=false,    % No muestra espacios especiales en las cadenas
    frame=single,              % Añade un marco alrededor del código
    numbers=left,              % Números de línea a la izquierda
    numberstyle=\small,        % Tamaño de fuente de los números de línea
    captionpos=b,              % Posición del título en la parte inferior
    escapeinside={(*@}{@*)}    % Permite añadir LaTeX dentro del código
}

%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\setlength{\droptitle}{-4\baselineskip} % Move the title up

\pretitle{\begin{center}\huge\bfseries} % Article title formatting
	\posttitle{\end{center}} % Article title closing formatting

\title{Desenrolle de lazos internos con optimización de operaciones de reducción} % Article title

\date{\today} % Leave empty to omit a date
\renewcommand{\maketitlehookd}{%
	\begin{abstract}
		\noindent En este informe, se abordará el tema del desenrolle de lazos para la optimización de operaciones de reducción, tal que se verá en que consiste la técnica y se comentarán experimentos.  \\\mbox{}\\
		 \textbf{\textit{Palabras clave}: bucles, lazos, desenrollamiento, optimización\ldots}
	\end{abstract}
}

%----------------------------------------------------------------------------------------

\begin{document}
	
	% Print the title
	\maketitle
	
	%----------------------------------------------------------------------------------------
	%	ARTICLE CONTENTS
	%----------------------------------------------------------------------------------------
	
	\section{Introducción}

        En el presente informe se describe una serie de experimentos diseñados para estudiar la técnica denominada desenrollamiento de lazos, en el contexto de operaciones de reducción.
        
        Para el estudio, se realizarán varios programas breves escritos en el lenguaje de bajo nivel C, ejecutados en un sistema operativo UNIX. Para la medición de los tiempos de ejecución de los bucles for se utilizará la librería \textit{sys/time.h}.

 
%	Introducción al problema tratado, incluyendo las referencias  necesarias. Por ejemplo: ``Este trabajo se basa en los estudios teóricos realizados en~\cite{Intel:2005} y \cite{spec}". En este apartado se plantean el problema a resolver, objetivos a alcanzar y metodología seguida para alcanzarlos.
	
%	Es una introducción al problema, no se desarrollarán los contenidos aquí. 
	
%	La introducción termina indicando en pocas palabras de qué secciones consta el resto del documento y de qué trata cada una. Se mencionan todas las secciones salvo la de referencias (bibliografía). 

	%------------------------------------------------
	
%-------------------------------------------

\section{Descripción de la técnica analizada: Loop Unrolling}

El desenrollamiento de lazos (loop unrollig en inglés), es una técnica que consiste en intentar minimizar el coste temporal de un bucle o lazo, mediante la reducción del número de iteraciones del mismo. 

Básicamente lo que hacemos en esta es la de eliminar o reducir las iteraciones necesarias para realizar una operación, reduciendo así el tiempo de ejecución de la misma. 

Un sencillo ejemplo es el siguiente:

\begin{lstlisting}[caption={Bucle sin desenrollar},label={lst:codigoC}]
	// This program does not uses loop unrolling. 
	#include<stdio.h> 
	
	int main(void) 
	{ 
		for (int i=0; i<5; i++) 
			printf("Hello\n"); //print hello 5 times 
	
		return 0; 
	}
\end{lstlisting}

\begin{lstlisting}[caption={Bucle aplicando la técnica},label={lst:codigoC}]
	// This program uses loop unrolling. 
	#include<stdio.h> 
	
	int main(void) 
	{ 
		// unrolled the for loop in program 1 
		printf("Hello\n"); 
		printf("Hello\n"); 
		printf("Hello\n"); 
		printf("Hello\n"); 
		printf("Hello\n"); 
	
		return 0; 
	} 
\end{lstlisting}

Ambos programas [1] nos muestran un sencillo ejemplo de la aplicación de esta técnica, pudiendo observar en el segundo caso se ha eliminado por completo el bucle, reduciendo así el tiempo de ejecución del programa, debido a que dentro del bucle es necesario hacer una comprobación del índice, lo que ralentiza el código. 

Otra manera diferente, para lazos donde eliminar el bucle por completo no es posible, se pueden reducir el número de iteraciones realizando varias operaciones en una sola iteración. 

Por ejemplo: imaginemos que tenemos un bucle el cual almacena en una variable el sumatorio de los números del 1 al 10. En un bucle sin desenrollamiento tendríamos que realizar 10 iteraciones, donde en cada una realizamos una operación. Sin embargo, podemos reducir el número de iteraciones a la mitad si en vez de sumar de uno en uno, sumamos de dos en dos, y a su vez podríamos reducirlo a 2 iteraciones si sumamos de 5 en 5. Esto es la otra manera (y que a su vez veremos posteriormente en los experimentos) de aplicar la técnica de desenrollamiento de lazos.

\section{Beneficios y desventajas}

Como casi cualquier herramienta que podamos utilizar, esta técnica conlleva una serie de ventajas y desventajas. Algunas de las ventajas que podemos encontrar son:

\textbf{Ventajas:}
\begin{enumerate}
	\item \textbf{Reducción de la Sobrecarga de Ciclos de Bucle:} En cualquier sistema, reducir la frecuencia con la que se evalúan las condiciones del bucle y se actualizan las variables de control puede mejorar el rendimiento al disminuir la sobrecarga general del bucle.
	\item \textbf{Incremento en el Paralelismo:} En sistemas con capacidades de procesamiento paralelo, desenrollar bucles puede permitir que múltiples operaciones se ejecuten al mismo tiempo, mejorando el uso del paralelismo inherente al hardware.
	\item \textbf{Mejor Uso de las Unidades de Procesamiento:} Al desenrollar un bucle, se pueden realizar más cálculos por cada entrada al bucle, lo cual puede ser eficiente en términos de aprovechamiento del tiempo de CPU y la ejecución en pipelining.
    \item \textbf{Reducción en el Tiempo de Ciclo de Reloj:} A medida que se desenrollan los bucles y el área utilizada se reduce inicialmente, puede resultar en un decremento en el tiempo de ciclo de reloj, lo cual potencialmente incrementa la frecuencia de operación y por ende la velocidad de procesamiento.
    \item \textbf{Disminución en el Uso del Área de FPGA (Field Programmable Gate Array) en Ciertos Casos:} Inicialmente, el desenrollamiento puede llevar a una reducción en el área utilizada, lo que es beneficioso cuando el área es una limitante crítica en el diseño del sistema.
\end{enumerate}

\textbf{Desventajas:}
\begin{enumerate}
	\item \textbf{Aumento del Tamaño del Código:} Desenrollar bucles aumenta la cantidad de código que se ejecuta, lo cual puede llevar a un mayor uso de la memoria de instrucciones y potencialmente a un caché de instrucciones más ocupado.
	\item \textbf{Complicaciones en la Gestión de la Memoria:} El aumento en la cantidad de operaciones ejecutadas simultáneamente puede hacer que la gestión de memoria sea más compleja y puede presionar al ancho de banda de memoria disponible.
	\item \textbf{Limitaciones por Dependencias de Datos:} Si existen dependencias de datos dentro de las iteraciones de un bucle, el desenrollamiento puede no ser aplicable sin modificar significativamente el algoritmo o puede llevar a la ejecución ineficiente debido a la espera de datos.
	\item \textbf{Inflexibilidad en la Modificación del Código:} El código desenrollado es menos flexible para modificaciones futuras o ajustes de parámetros del bucle, ya que cualquier cambio requiere más esfuerzo para actualizar todas las instancias desenrolladas del bucle.
\end{enumerate}

Por tanto, viendo las ventajas y las desventajas, el programador deberá valorar si aplicar esta técnica en su código, ya que aunque puede mejorar el rendimiento, también puede conllevar una serie de problemas.

\section{Experimentos}

Para los experimentos, se ha realizado un programa en C que mide los dos siguiente bucles:

\begin{lstlisting}[caption={Bucle sin desenrollar},label={lst:codigoC}]
	for(k=0; k<ITER; k++){
        a=0.0;
        for(i=0; i<N; i++){
            a = a + x[i] * y[i];
        }
    }
\end{lstlisting}

\begin{lstlisting}[caption={Bucle aplicando la técnica},label={lst:codigoC}]
	for(k=0; k<ITER; k++){
        a = a1 = a2 = a3 = 0.0;

        for(i=0; i<N; i+=4){
            a = a + x[i] * y[i];
            a1 = a1 + x[i+1] * y[i+1];
            a2 = a2 + x[i+2] * y[i+2];
            a3 = a3 + x[i+3] * y[i+3];
        }   

        a = a + a1 + a2 + a3;
    } 
\end{lstlisting}

En el primer bucle [3], se realiza la operación de producto escalar de dos vectores de tamaño N, y se repite ITER veces. En el segundo bucle [4], se ha desenrollado el bucle interno, realizando 4 operaciones en cada iteración.

Por tanto sobre estos dos lazos realizarán experimentos modificando el valor de N y de ITER, para ver como afecta el desenrollamiento de lazos en el tiempo de ejecución del programa.

Un detalle a destacar sobre la implementación del código, es la necesidad de limpiar la caché antes de realizar las mediciones, ya que si no se hace, puede afectar a la precisión de los datos medidos. Para ello, se ha implementado la función \textit{clearCache()} la cual, sirviéndose del tamaño de la caché L1d, crea un array de este tamaño para posteriormente rellenarlo entero y posteriormente liberándolo. Debido al tamaño del programa no es necesario limpiar la caché L2, ya que el tamaño de la anterior es de 64KB, y no llega a sobrepasar este tamaño.

\subsection{Tiempos de ejecución}

Para el primer experimento vamos a realizar una serie de mediciones variando el tamaño de ITER, con un tamaño de array fijo, y veremos como afecta al tiempo de ejecución del programa.

Para analizarlo correctamente nos serviremos de la siguiente gráfica:

\begin{figure}[H]
    \centering
    \hspace{1cm}
    \includegraphics[width=\columnwidth]{img/exeTimes.jpg}
    \caption{Gráfica de tiempo de ejecución en función de ITER}
    \label{fig:iter}
\end{figure}

La gráfica nos muestra dos curvas, azul para el bucle normal y naranja para el bucle desenrollado. Como se puede fácilmente observar obtenemo slas siguientes conclusiones:

\begin{itemize}
    \item \textbf{Mejora del rendimiento con el desenrollamiento:} El bucle desenrollado muestra consistentemente tiempos de ejecución inferiores en comparación con el bucle normal a lo largo de todo el rango de iteraciones. Esto indica que el desenrollamiento de bucles puede ser una técnica efectiva para optimizar el rendimiento de los programas en términos de tiempo de ejecución.
    \item \textbf{Escalabilidad:} A medida que aumenta el número de iteraciones, el impacto del desenrollamiento de bucles en la mejora del rendimiento parece ser más pronunciado. La curva del bucle normal muestra un crecimiento más rápido que la del bucle desenrollado, lo que sugiere que la técnica de desenrollamiento se vuelve más ventajosa a gran escala.
    \item \textbf{Crecimiento lineal:} Ambas curvas parecen seguir un patrón de crecimiento lineal, lo cual es esperable ya que el tiempo de ejecución debería aumentar proporcionalmente con el número de iteraciones. No obstante, la pendiente de la curva del bucle desenrollado es claramente menos inclinada, lo que sugiere una menor adición de tiempo por cada iteración adicional en comparación con el bucle normal.
\end{itemize}

Sin embargo, y a pesar de las mejoras descritas, hay que tener en cuenta que con números bajos de iteraciones, ambos bucles no distan tanto en tiempo de ejecución, por lo que habría que estudiar si en estos casos sería beneficioso aplicar la técnica.

\subsection{Por tamaño de array}

En este segundo experimento a realizar, haremos lo contrario al anterior, es decir, mantendremos un tamaño fijo de iteraciones (5000) y variaremos el tamaño del array.

Esto nos permitirá ver como el unrolling afecta a diferentes tamaños de datos, y si verdaderamente es eficaz, frente a un bucle normal sin desenrollar.

Como en el anteriro experimento nos serviremos de la siguiente gráfica, donde el eje X es el tamaño del array (N) y el eje Y el tiempo de ejecución:


\begin{figure}[H]
    \centering
    \includegraphics[width=\columnwidth]{img/arrayTam.jpg}
    \caption{Gráfica de tiempo de ejecución en función de N}
    \label{fig:iter}
\end{figure}

Al igual que en el experimento anterior, podemos sacar unas conclusiones similares:

\begin{itemize}
    \item El tiempo de ejecución para el bucle normal aumenta linealmente con el tamaño del array, lo que indica una relación directa entre el tamaño del array y el tiempo de cómputo requerido.
    \item El bucle desenrollado demuestra una eficiencia notablemente mayor. Aunque el tiempo de ejecución también crece con el tamaño del array, lo hace a una tasa menor que el bucle normal.
    \item La diferencia de tiempo entre los dos enfoques se amplía con el aumento del tamaño del array. Esto sugiere que para arrays grandes, el desenrollamiento de bucles puede ser especialmente beneficioso.
    \item La técnica de desenrollamiento de bucles se confirma como una optimización efectiva para la reducción de la sobrecarga de los bucles y el aprovechamiento del paralelismo del hardware, lo cual es crítico en aplicaciones de procesamiento de datos de gran volumen.
\end{itemize}

Estos resultados son muy similares a los obtenidos en el experimento anterior, lo que nos lleva a pensar que la técnica de desenrollamiento de lazos es efectiva en la reducción de tiempos de ejecución en bucles de gran tamaño.

\subsection{Mejora de Rendimiento}

En este apartado vamos a calcular el porcentaje de mejora de rendimiento de una técnica respecto a la otra aplicando la siguiente fórmula:

\begin{equation}
    \text{Mejora de Rendimiento (\%)} = \left( \frac{ts - td}{ts} \right) \times 100\%
\end{equation}

Donde \( ts \) representa el tiempo sin desenrollar y \( td \) el tiempo con desenrollado. 

Para representar esto nos serviremos del siguiente historiograma:   

\begin{figure}[H]
    \centering
    \includegraphics[width=\columnwidth]{img/improvement.png}
    \caption{Histograma de la mejora de rendimiento al aplicar la técnica de desenrollamiento de bucles.}
    \label{fig:histograma_mejora_rendimiento}
\end{figure}


A partir del histograma, se pueden extraer varias conclusiones:

\begin{itemize}
    \item La mejora de rendimiento tras aplicar el desenrollamiento de bucles es consistentemente positiva, lo que indica que esta técnica ofrece beneficios en todos los casos probados.
    \item La mejora porcentual parece ser más significativa en tamaños de array más pequeños. Esto puede deberse a que el desenrollamiento reduce la sobrecarga del control del bucle, que es más notable cuando la carga de trabajo del bucle es menor.
    \item A medida que el tamaño del array aumenta, la mejora porcentual se reduce. Sin embargo, incluso para los tamaños de array más grandes, la técnica aún proporciona un beneficio notable.
\end{itemize}

Es importante considerar que el desenrollamiento de bucles puede introducir complejidad adicional en el código y podría aumentar el tamaño del binario final. Por lo tanto, la decisión de aplicar esta técnica debe balancear la mejora de rendimiento contra estos posibles inconvenientes.

\subsection{Tiempo Real vs Tiempo de CPU}

En este cuarto experimento, comparamos el tiempo de CPU con el tiempo real para ambas técnicas de ejecución del bucle, con el fin de observar diferencias entre estos y determinar si el desenrollamiento de lazos afecta de manera distinta a estos dos tipos de medición de tiempo.

\begin{figure}[H]
    \centering
    \includegraphics[width=\columnwidth]{img/times.png}
    \caption{Comparación del tiempo real versus el tiempo de CPU para bucles normal y desenrollado.}
    \label{fig:real_vs_cpu_time}
\end{figure}

A partir de la gráfica obtenemos varias conclusiones:

\begin{itemize}
    \item Se observa que el tiempo de CPU y el tiempo real para el bucle normal son muy similares a lo largo de todas las iteraciones, lo que indica una correlación directa entre ellos y sugiere una eficiencia constante en la ejecución.
    \item Para el bucle desenrollado, tanto el tiempo real como el de CPU son consistentemente menores en comparación con el bucle normal, reafirmando la efectividad del desenrollamiento en la reducción del tiempo total de ejecución.
\end{itemize}

Estas observaciones resaltan la importancia de considerar tanto el tiempo de CPU como el tiempo real al evaluar optimizaciones de código, ya que proporcionan una visión más completa del rendimiento y la eficiencia del programa, y podemos concluir que dado que ambos tiempos para cada técnica son muy similares, las las mejoras son similares a las obtenidas en los experimentos anteriores.




%------------------------------------------------
	
\section{Conclusiones}



%----------------------------------------------------------------------------------------
%	Referencias
%----------------------------------------------------------------------------------------
	
\begin{thebibliography}{99} % Bibliografía - alternativamente, se recomienda el uso de bibtex o biblatex

    \bibitem[1]{LoopUnrollingGeeksforGeeks}
    GeeksforGeeks.
    \newblock {\em Loop Unrolling}.
    \newblock \url{https://www.geeksforgeeks.org/loop-unrolling/}, \newblock [online]
    
    \bibitem[2]{Dragomir2009}
    O. S. Dragomir, T. Stefanov, and K. Bertels.
    \newblock Optimal Loop Unrolling and Shifting for Reconfigurable Architectures.
    \newblock {\em ACM Transactions on Reconfigurable Technology and Systems}, Vol. 2, No. 4, Article 25, September 2009, 24 pages.
    \newblock DOI = 10.1145/1575779.1575785.
    \newblock \url{http://doi.acm.org/10.1145/1575779.1575785}, \newblock [online]

    \bibitem[3]{Buyukkurt2004}
    Betul Buyukkurt, Zhi Guo, and Walid A. Najjar.
    \newblock {\em Impact of Loop Unrolling on Area, Throughput and Clock Frequency in ROCCC: C to VHDL Compiler for FPGAs}.
    \newblock Department of Computer Science and Engineering, University of California - Riverside, Riverside, CA 92507, USA.
    
\end{thebibliography}


	
	%----------------------------------------------------------------------------------------
	
\end{document}

